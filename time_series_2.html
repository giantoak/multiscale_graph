<!DOCTYPE html>
<head>
<meta charset="utf-8">
    <meta http-equiv="cache-control" content="max-age=0" />
    <meta http-equiv="cache-control" content="no-cache" />
    <meta http-equiv="expires" content="0" />
    <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
    <meta http-equiv="pragma" content="no-cache" />
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap-theme.min.css">
    <script src="./jquery-1.11.1.min.js"></script>
    <script src="http://code.jquery.com/ui/1.10.4/jquery-ui.js"></script>
    <link rel="stylesheet" href="//code.jquery.com/ui/1.10.4/themes/smoothness/jquery-ui.css">
    <style>
        
        body {
            font: 10px sans-serif;
        }
        
        .axis path,
        .axis line {
            fill: none;
            stroke: #000;
            shape-rendering: crispEdges;
        }
        
        /*
         .x.axis path {
         display: none;
         }
         */
        
        .button {
            font-size:12pt;
            
        }
        
        .line {
            stroke: black;
            fill: none;
            stroke-width: 0.75px;
        }
        
        .line.line0 {
            stroke: steelblue;
           
        }
        
        .line.line1 {
            stroke: indianred;
            
        }
        
        .overlay {
            fill: none;
            pointer-events: all;
        }
        
        .focus circle {
            fill: none;
        }
        
        .focus circle.y0 {
            stroke: blue;
            fill : blue;
            
        }
        
        .focus circle.y1 {
            stroke: red;
            fill: red;
        }
        
        .focus line {
            stroke: purple;
            shape-rendering: crispEdges;
        }
        
        .focus line.y0 {
            stroke: steelblue;
            stroke-dasharray: 3 3;
            opacity: .5;
        }
        
        .focus line.y1 {
            stroke: indianred;
            stroke-dasharray: 3 3;
            opacity: .5;
        }
        
        line.time_marker {
            stroke:black;
            stroke-dasharray: 2 2;
            opacity:.9;
            
        }
        
        
        .brush .extent {
            stroke: #fff;
            fill-opacity: .125;
            shape-rendering: crispEdges;
        }
        
        /*#container2 .node {
            stroke: #fff;
            stroke-width: 1.5px;
        }*/
        
       #container2 .node:not(:hover) .nodetext {
            display: none;
        }
        
  
        
        #container2 .link {
            stroke: #999;
            stroke-opacity: .6;
        }
        
        #container2 text {
            font: 10px sans-serif;
            pointer-events: none;
        }
        
        .legend {
            padding: 5px;
            font: 10px sans-serif;
            background: yellow;
            box-shadow: 2px 2px 1px #888;
        }
        
        p a.btn {
            position: relative;
            bottom:5px;
        }
        
  
        
        </style>
        <script>
		/*
			Dialog interactivity script component.

				1. The Call to dialog function takes an object that controls the behavior of the
				   'dialog box' which is opened as a results of this call.

				2. It uses the JQuery shorthand for $(document).ready() - which ensures that the
				   DOM is ready for use by Javascript.

				3. The action associated with the Submit button adds data present on the two
				   input fields in the dialog's DIV, into an array of objects.  These objects
				   is defined as:

					a. date - This value contains the event's incident date

					b. des - The user definition of that incident.

		*/

		/************************************************************************
			To abstract this out the following things need to be done

			1. Define a DialogBox javascript class with at least the following
			   properties:

				a. Id of DIV providing the DOM elements to be manipulated.

				b. The name of the property to assigned the array of 
				   data object representing the information being collected
				   by the dialog.

				c. A Javascript class constructor which knows how to 
				   pull the data from the DIV being manipulated.  

			The main part of the Submit logic would be changed to look something like:

			// Check if this is the first time
			if (typeof($(this.ElementId).data(this.dataProperty) == "undefined") {

				// Add the array and define the first element.
				$(this.ElementId).data(this.dataProperty, [new this.objectContructor()]);
			} else {

				// Add another element to the array
				$(this.ElementId).data(this.dataProperty).push(new this.objectContructor());
			}
 
		************************************************************************/

            $(function() {
              $( "#dialog" ).dialog({
                                    modal: true,
                                    autoOpen:false,
                                    buttons: {
                                    Submit: function(){ if(typeof $("#dialog").data("position") == "undefined")
                                    {
					// Creates both the array and the first object
                                        $( "#dialog" ).data("position",[{date:parseInt($('input#date').map(function () 
                                                { return this.value; 
                                                }).get(),10),des:$('input#description').map(function () {
                                                  return this.value;})}]);

                                    }
                                                                                                                                                                                                                               
                                    else {

					// Appends another object into the array
					$( "#dialog" ).data("position").push({date:parseInt($('input#date').map(function () 							{ return this.value;
                                                }).get(),10),des:$('input#description').map(function () {
                                                return this.value;})});
                                    
                                    }

				    // Closes the dialog after a user has updated the data array	
                                    $( this ).dialog( "close" );
                                    },
                                    Cancel: function() {
                                    $( this ).dialog( "close" );
                                    }
                                    }
                                    });
              

	    // Adds the click handler to the BUTTON with the id of EVENT 
	    //  This event handler opens the DIALOG DIV
            $( "#events" )
			.button()
			.click(function() {
                   $( "#dialog" ).dialog( "open" );
                   });
            });
        </script>
    <body>
        <div id="container" style="width:700px;border: 0px solid; float: left">
        
	    <!-- Dialog Box Form -->
            <div id="dialog" title="Timeline">
                <p>Enter dates of interest:</p>
                <form>
                    <fieldset>
                        <label for="name">Date</label><br>
                        <input type="text" name="date" id="date" class="text ui-widget-content ui-corner-all"><br>
                            <label for="date">Description</label><br>
                            <input type="text" name="description" id="description" value="" class="text ui-widget-content ui-corner-all"></input>
                    </fieldset>
                </form>
            </div>

	    <!-- Combo Box defining how the timeseries data is displayed -->
            <select class="form-control" id="stats_select" value="one">
                <option value="one">Scan statistics</option>
                <option value="two">Modularity</option>
                <option value="three">Graph Compression</option>
                <option value="four">Connected Components</option>
                <option value="five">Density</option>
                <option value="six">Average Clustering Coefficient</option>
                <option value="seven">Assortativity</option>
        </select>
        </div>

	<!-- This DIV doesn't appear to be used.  -->
        <div id="big_container" style="border: 0px solid; margin-left: 730px">

	<!-- The BUTTON to trigger the opening of the 'dialog box' -->
        <button id="events">Add known event<br></button>

	<!-- This DIV holds the Node Graph for a specific week -->
        <div id="container2" style="border: 0px solid;height: 450px;" ></div>
        
	<!-- This DIV holds the BUTTONS used to move through the data set -->
        <div id="nav">
			<center>
				<button type="button" class="btn btn-default" id="left">
					<span class="glyphicon glyphicon-chevron-left"></span>
				</button>
				<button type="button" class="btn btn-default" id="right">
					<span class="glyphicon glyphicon-chevron-right"></span>
				</button>
				<br>
			</center>

			<!-- This DIV holds the additional display options for Node Graph -->
            <div class="form-inline" margin-left:"100px">
                    <h4>Node color</h4>
                    <div>
						<label class="checkbox">
						<input type="checkbox" value="eig" class="color">Eigenvector Centrality</label>
                    </div>
                     <div>
                            <label class="checkbox">
							<input type="checkbox"  value="bc" class="color">Betweenness</label>
                     </div>
                     <div>
                            <label class="checkbox">
								<input type="checkbox"  class="color">Degree</label>
                      </div>
                     <div>
                            <label class="checkbox">
							<input type="checkbox" value="sg" class="color">Anomalous Subgraphs</label>
                      </div>
                
                </div>
        
        </div>
        </div>
        
		<!-- Pulls in the D3.JS Script library -->
        <script type="text/javascript" src="./d3.min.js"></script>
        <script>

			// Display the Scan Statistics data set
            load_stats("one");
       
            // Initialize the visualization state
            window.id_them=0;
            window.week=0;
            window.id_us=0;
            window.position=[];

            // Add the click event handler for the GUI element responsible for managing the
			// Switching between the Stats Graph being displayed.
            $('#stats_select').click(function(e) {
								
								// Get the Statistics Identifier
                                var stats = $('#stats_select').val();

								// Dump the data set being displayed.
								d3.select("svg").remove();

								// Load the identified data set
								load_stats(stats);

								// prevent the default anchor functionality
                                e.preventDefault();
                                });

			// Save the value used to identify which data set to display
            var stats=$('#stats_select').val();
            
			// The function responsible for displaying a Statistics data set 
            function load_stats(stats){
                
			// Define page layout properties
            var main_margin = {top: 20, right: 80, bottom: 100, left: 40},
            mini_margin = {top: 430, right: 80, bottom: 20, left: 40},
            main_width = 800 - main_margin.left - main_margin.right,
            main_height = 500 - main_margin.top - main_margin.bottom,
            mini_height = 500 - mini_margin.top - mini_margin.bottom;
            
			// Standardize display formatting of Time values (hours:minutes)
            var formatDate = d3.time.format("%H:%M"),
            parseDate = formatDate.parse,

			// Extract and manipulate Time Information out of the data set
            bisectDate = d3.bisector(function(d) { return d.Uhrzeit; }).left,
            formatOutput0 = function(d) { return formatDate(d.Uhrzeit) + " - " + d.Durchschn + " ms"; },
            formatOutput1 = function(d) { return formatDate(d.Uhrzeit) + " - " + d.Anz; };
            
			// Define the Ranges for X-Axes of the Main Graph Display and Mini Graph Display
            var main_x = d3.scale.linear()
							.range([0, main_width]),
            mini_x = d3.scale.linear()
							.range([0, main_width]);
            
			// Define the Ranges for Y-Axes of the Main Graph Display and Mini Graph Display

			/***************************************************************************
				Why are two y ranges were created?  (Maybe this is just a note to self...)
			***************************************************************************/
            var main_y0 = d3.scale.sqrt()
							.range([main_height, 0]),
            main_y1 = d3.scale.sqrt()
							.range([main_height, 0]),
            mini_y0 = d3.scale.sqrt()
							.range([mini_height, 0]),
            mini_y1 = d3.scale.sqrt()
							.range([mini_height, 0]);
            
			// Create the Graph's X Axis element
            var main_xAxis = d3.svg.axis()
				            .scale(main_x)
				            .orient("bottom"),
            mini_xAxis = d3.svg.axis()
				            .scale(mini_x)
				            .orient("bottom");
            
			// Create the Graph's Y Axis element
            var main_yAxisLeft = d3.svg.axis()
						            .scale(main_y0)
						            .orient("left");
            main_yAxisRight = d3.svg.axis()
					            .scale(main_y1)
					            .orient("right");

			/***************************************************************************
				Variable and function (brush) shouldn't have the same name.  These 
				values should become two different properties of the Time Series object 
				being inserted into a page.  Additionally, this Object's constructor 
				should actually create the needed additional SVG elements.  So, the 
				constructor should require an ID for the container DIV.

				The Dialog Object should be added to this object as it needs that
				function.

				Most of the code from here upto the open SCRIPT tag should be integrated
				into this new object.
			***************************************************************************/
            
			// Defines the object used to manage the scrubber window on the mini
			// Full data set display graph

            var brush = d3.svg.brush()
            .x(mini_x)
            .on("brush", brush);
            
			// Defines the both curves on the larger graph
            var main_line0 = d3.svg.line()
					            .interpolate("monotone")
					            .x(function(d) { return main_x(d.Uhrzeit); })
					            .y(function(d) { return main_y0(d.Durchschn); });
            
            var main_line1 = d3.svg.line()
					            .interpolate("monotone")
					            .x(function(d) { return main_x(d.Uhrzeit); })
					            .y(function(d) { return main_y1(d.Anz); });
            
            // Defines both curves on the mini/scrubber window
            var mini_line0 = d3.svg.line()
					            .x(function(d) { return mini_x(d.Uhrzeit); })
					            .y(function(d) { return mini_y0(d.Durchschn); });
            
            var mini_line1 = d3.svg.line()
					            .x(function(d) { return mini_x(d.Uhrzeit); })
					            .y(function(d) { return mini_y1(d.Anz); });
                
            // No longer used?
            var time_line = d3.svg.line()
				                .x(function(d) { return mini_x(d.Uhrzeit); })
                				.y(function(d) { return main_height; });
                
            // Create the SVG element for the two graphs prepresenting the time series
			// data set, the mini - full data set viewer and larger - 'detailed' view.
            var svg = d3.select("#container").append("svg")
			            .attr("width", main_width + main_margin.left + main_margin.right)
            			.attr("height", main_height + main_margin.top + main_margin.bottom)
			            .attr("id","main");

            // Define the clip path so that the 'zoomed' graph will only be displayed
			// the visible area of the graph.
            svg.append("defs").append("clipPath")
            			.attr("id", "clip")
            			.append("rect")
            			.attr("width", main_width)
            			.attr("height", main_height);
            
			// Main is the SVG element which defines visible area of the graph
            var main = svg.append("g")
            .attr("transform", "translate(" + main_margin.left + "," + main_margin.top + ")");
            
			// Mini is the SVG element which defines the full data set viewer
            var mini = svg.append("g")
            .attr("transform", "translate(" + mini_margin.left + "," + mini_margin.top + ")");
            
			// Loads data from the SS_DUMP python script hosted in the Tangelo server  
            d3.json("ss_dump", function(error, data) {

					// Identify which statistical data set to process
                   	var stats=$('#stats_select').val();

					// Transform the raw data records into an 'abstracted' data structure used
					// to display the two curves.
                   	data.forEach(function(d) {


								// Connected Components
                                if (stats=='four'){
                                d.Uhrzeit = d.x;
                                d.Durchschn = d.cc;
                                //d.Anz = d.them;
                                }
								// Density
                                else if (stats=='five'){
                                d.Uhrzeit = d.x;
                                d.Durchschn = d.density.toFixed(10);
                                
                                }
								// Average Clustering Coefficient
                                else if (stats=='six'){
                                d.Uhrzeit = d.x;
                                d.Durchschn = d.transitivity;
                                
                                }
								// Assortativity
                                else if (stats=='seven'){
                                    d.Uhrzeit=d.x;
                                    d.Durchschn=d.assortativity;
                                }
								// Fall through for:
								//		Scan statistics
								//		Modularity
								//		Graph Compression

                                else {
                                d.Uhrzeit = d.x;
                                d.Durchschn = d.us
                                d.Anz = d.them;
                                
                                }
                                });
                   
					// Sort the data set in ascending time stamps order
					data.sort(function(a, b) {
                             return a.Uhrzeit - b.Uhrzeit;
                             });
                  
                   
					// Set the Domain & Ranges for the Main Graph's Axes 	
					main_x.domain([data[0].Uhrzeit, data[data.length - 1].Uhrzeit]);
					main_y0.domain(d3.extent(data, function(d) { return d.Durchschn; }));
					main_y1.domain(d3.extent(data, function(d) { return d.Anz; }));

					// Set the Domain & Ranges for the full data set viewer axes
					mini_x.domain(main_x.domain());
					mini_y0.domain(main_y0.domain());
					mini_y1.domain(main_y1.domain());
                   
					// Draw the 'line' defined by the data set within the clipping path
					main.append("path")
						.datum(data)
						.attr("clip-path", "url(#clip)")
						.attr("class", "line line0")
						.attr("d", main_line0);
                   
					main.append("path")
						.datum(data)
						.attr("clip-path", "url(#clip)")
						.attr("class", "line line1")
						.attr("d", main_line1);
                   
					// Create the x-axis of the larger graph
					main.append("g")
						.attr("class", "x axis")
						.attr("transform", "translate(0," + main_height + ")")
						.call(main_xAxis);
                   
					
					// Create the y-axis of the larger graph
					main.append("g")
						.attr("class", "y axis axisLeft")
						.call(main_yAxisLeft)
						.append("text")
						.attr("transform", "rotate(-90)")
						.attr("y", 6)
						.attr("dy", ".71em")
						.style("text-anchor", "end");
                   
                   
                   /*main.append("g")
                   .attr("class", "y axis axisRight")
                   .attr("transform", "translate(" + main_width + ", 0)")
                   .call(main_yAxisRight)
                   .append("text")
                   .attr("transform", "rotate(-90)")
                   .attr("y", -12)
                   .attr("dy", ".71em")
                   .style("text-anchor", "end")
                   .text("them");
                   */
                    
                   // Create the x-axis of the mini/scrubber graph
                   mini.append("g")
                   .attr("class", "x axis")
                   .attr("transform", "translate(0," + mini_height + ")")
                   .call(main_xAxis);
                   
                   // Create the 'line' on the mini/scrubber graph
                   mini.append("path")
                   .datum(data)
                   .attr("class", "line")
                   .attr("d", mini_line0);
                   
                   // Create the 'line' on the mini/scrubber graph
                   mini.append("path")
                   .datum(data)
                   .attr("class", "line")
                   .attr("d", mini_line1);
                   
                   // Create the 'zoom' window overlay for the mini/scrubber graph 
                   mini.append("g")
                   .attr("class", "x brush")
                   .call(brush)
                   .selectAll("rect")
                   .attr("y", -6)
                   .attr("height", mini_height + 7);
                    
                   // Create the element used to manage the points of interest on the large graph
                   var focus = main.append("g")
                   .attr("class", "focus")
                   .style("display", "none");
                   
                   // Anzeige auf der Zeitleiste
                   focus.append("line")
                   .attr("class", "x")
                   .attr("y1", main_y0(0) - 6)
                   .attr("y2", main_y0(0) + 6)
                   
                   // Anzeige auf der linken Leiste
                   focus.append("line")
                   .attr("class", "y0")
                   .attr("x1", main_width - 6) // nach links
                   .attr("x2", main_width + 6); // nach rechts
                   
                   // Anzeige auf der rechten Leiste
                   focus.append("line")
                   .attr("class", "y1")
                   .attr("x1", main_width - 6)
                   .attr("x2", main_width + 6);
                   
                   // Create the point of intersection marker on the first 'line'
                   focus.append("circle")
                   .attr("class", "y0")
                    .attr("r", 4);
                   
                   // Create the label for that point of intersection
                   focus.append("text")
                   .attr("class", "y0")
                   .attr("dy", "-1em");
                   
                   // Create the point of intersection marker on the second 'line'
                   focus.append("circle")
                   .attr("class", "y1")
                   .attr("r", 4);
                   
                   // Create the label for that point of intersection
                   focus.append("text")
                   .attr("class", "y1")
                   .attr("dy", "-1em");
                   
                   // Add the support for user interactivity with the main graph
                   main.append("rect")
                   .attr("class", "overlay")
                   .attr("width", main_width)
                   .attr("height", main_height)
                   .on("mouseover", function() { focus.style("display", null); })
                   .on("mouseout", function() { focus.style("display", "none"); })
                   .on("mousemove", mousemove)
                   .on("click",mouseclicker);
                   
                   // Mouse Move Event Handler function to provide feedback to the user showing the intersection points on the graph
                   function mousemove() {
                   var x0 = main_x.invert(d3.mouse(this)[0]),
                   i = bisectDate(data, x0, 1),
                   d0 = data[i - 1],
                   d1 = data[i],
                   d = x0 - d0.Uhrzeit > d1.Uhrzeit - x0 ? d1 : d0;
                   
                   // Update the visual feedback elements as the user moves the mouse
                   focus.select("circle.y0").attr("transform", "translate(" + main_x(d.Uhrzeit) + "," + main_y0(d.Durchschn) + ")");
                   focus.select("text.y0").attr("transform", "translate(" + main_x(d.Uhrzeit) + "," + main_y0(d.Durchschn) + ")").text(d.Durchschn);
                   focus.select("circle.y1").attr("transform", "translate(" + main_x(d.Uhrzeit) + "," + main_y1(d.Anz) + ")");
                   focus.select("text.y1").attr("transform", "translate(" + main_x(d.Uhrzeit) + "," + main_y1(d.Anz) + ")").text(d.Anz);
                   //focus.select(".x").attr("transform", "translate(" + main_x(d.Uhrzeit) + ",0)");
                   focus.select(".y0").attr("transform", "translate(" + main_width*-1 + ", " + main_y0(d.Durchschn) + ")").attr("x2", main_width + main_x(d.Uhrzeit));
                   focus.select(".y1").attr("transform", "translate(" + main_width*-1 + ", " + main_y1(d.Anz) + ")").attr("x2", main_width + main_x(d.Uhrzeit));
                    //focus.select(".y1").attr("transform", "translate(0, " + main_y1(d.Anz) + ")").attr("x1", main_x(d.Uhrzeit));
                   }

                // Mouse Click Event Handler function to afix the desired points of interest on the main graph
                function mouseclicker(){
                    //window.alert("Enter dates of interest");
                    var x1 = main_x(Math.round(main_x.invert(d3.mouse(this)[0])))
                    //window.position=window.position.insert(0,main_x.invert(x1));
                    window.position.push(main_x.invert(x1));
                    
                    // Prepare to add extra annotations if defined.
                    line_pos=$("#dialog").data("position").map(function(d){return d.date})
                    
                    // Debug that process...
                    console.log(line_pos)

                    // Actually at the extra annotations
                    main.append("g:line").attr("class","time_marker")
                    .data(line_pos)
                    .attr("x1", x1)
                    .attr("x2", x1)
                    .attr("y1",0)
                    .attr("y2",main_height)
                    .attr("d","time_marker");
                    
                    /********************************************************************
                    
                    	Should the annotations supercede marking points on the curve?
                    	Or is this being done each time because the process of afixing the
                    	points removes the annotation lines?
                    			
                    *********************************************************************/
                    
                    // Update the Graph's form with the user's selection, 
                    // so that other GUI elements can be correctly updated.
                    $("#container2").html("");
                    var week=parseInt(Math.round(main_x.invert(d3.mouse(this)[0])));
                    window.week=week;
                    //d3.select("#container2").append("p").text("t="+week+"\t"+data[week].id_them);
                    
                    window.id_them=data[week].id_them;
                    window.id_us=data[week].id_us;
                    var width=500, height=610;
                    
               
                    // Define a force graph to display the graph at the identified instance in time.
                    var force = d3.layout.force()
                    .charge(-120)
                    .linkDistance(30)
                    .size([width, height]);
                    
                    // Create the SVG elements for this Node Graph in another DIV
                    var svg2 = d3.select("#container2").append("svg")
                    .attr("width", width)
                    .attr("height", height)
                    .attr("pointer-events","all")
                    .append('svg:g')
                    .call(d3.behavior.zoom().on("zoom", redraw))
                    .append('svg:g');
                    
                    // Create the display area for this Node Graph
                    svg2.append('svg:rect')
                    .attr('width', width)
                    .attr('height', height)
                    .attr('fill', 'white');
                    
                    // Define a Draw Event Handler method
                    function redraw() {
                    svg2.attr("transform",
                              "translate(" + d3.event.translate + ")"
                              + " scale(" + d3.event.scale + ")");
                    }

                    // Fetch the data identified by the user's interactions.                    
                    d3.json("network_retrieval?date="+week, function(error, graph) {
                    	
                    	// Add the fectch data to the Node Graph instance.
                        force
                            .nodes(graph.nodes)
                            .links(graph.links)
                            .start();
                            
                            // Pull in additional node Label data
                            var employees_id=[];
                            d3.csv("employees_id.csv",function(data){
                            	
                            	// Associate the fetched data with the array defined to manage it.
                                employees_id=data
                                   
                                // Define a function to map this data set to the Graph data set.   
                            	function node_adder(nodes){
                            		
                                   for (var i=0; i < nodes.length; i++) {
                                        var index=findIndexByKeyValue(graph.nodes,"id",i)
                                        if(index!=null){
                                            graph.nodes[index].name=employees_id[i].V2
                                            }
                                        }
                                   }
                                   
                        // Request the mapping between the two data sets.
                        node_adder(employees_id);

                        // Create the Gradient for Node Coloring 
                        var color = d3.scale.linear()
                            .domain([0, 1])
                            .range(["red", "black"]);

                        // Define a SVG instance for the Links of the graphs
                        var link = svg2.selectAll("line.link")
                            .data(graph.links)
                            .enter().append("svg:line")
                            .attr("class", "link");
                            
                        // Define an Object for managing mapping between nodes in the graph
                        var linkedByIndex = {};
                        
                        // Define that mapping.
                        graph.links.forEach(function(d) {
                                          linkedByIndex[d.source.id + "," + d.target.id] = 1;
                                          });
                              
                        // Define a function to check if a pair of objects are linked     
                        function isConnected(a, b) {
                            return linkedByIndex[a + "," + b] || linkedByIndex[b + "," + a];
                            }
                        
                        // Clear the list of nodes identified
                        window.pink = [];
                        window.baby_blue=[];
                        
                        // Scan the nodes and assign them to an identifying collection
                        graph.nodes.forEach(function(d){
                        	
                               	if(isConnected(d.id,window.id_them)) {
                               		window.pink.push(d.id)
                               	}
                                                
                                if(isConnected(d.id,window.id_us)) {
                                	window.baby_blue.push(d.id)
                                }
                        });
                        
                       
                       // Add the data set to the nodes so they'll render
                       var node = svg2.selectAll("g.node")
                            			.data(graph.nodes)
                            		.enter().append("svg:g")
                            			.attr("class", "node")
                            			.call(force.drag);
                       
                       // Render the nodes
                       node.append("svg:circle")
                            .attr("class", "node")
                                   .attr("r", function(d) {return 1.5*Math.sqrt(d.degree+1)})
                            .style("fill", function(d) { if(d.id==window.id_them) return "red"; else if (isConnected(d.id,window.id_them)) return "pink"; else if (d.id==window.id_us) return "blue";  else if (isConnected(d.id,window.id_us)) return "lightblue"; else
                                   return "black"; });
                            
                      
                      // Add the labels for the nodes
                      node.append("svg:text")
                            .attr("class", "nodetext")
                            .attr("dx", 12)
                            .attr("dy", ".35em")
                            .text(function(d) { return d.name});

                      // Add the function that allows the force graph to reposition the Nodes of the graph      
                      force.on("tick", function() {
                                     link.attr("x1", function(d) { return d.source.x; })
                                     .attr("y1", function(d) { return d.source.y; })
                                     .attr("x2", function(d) { return d.target.x; })
                                     .attr("y2", function(d) { return d.target.y; });
                                     
                                     node.attr("transform", function(d) {
                                                 return 'translate(' + [d.x, d.y] + ')';
                                                 });
                                     });
                            
                                   });
                            });

                }
                    
            });
			
			// Define a function to add the annotations identified by the user.
            function brush() {
                    
                    main_x.domain(brush.empty() ? mini_x.domain() : brush.extent());
                    //console.log(main_x.domain()+' '+window.position+' '+ main_x.invert(window.position)+' ' + main_x(main_x.invert(window.position)))
                    main.select(".line0").attr("d", main_line0);
                    main.select(".line1").attr("d", main_line1);
                    main.selectAll("line.time_marker").data(window.position).attr("x1", function(d){ return main_x(d);});
                    main.selectAll("line.time_marker").data(window.position).attr("x2", function(d){ return main_x(d);});
                    main.select(".x.axis").call(main_xAxis);
                   
                }
            }
            
            // Define function to scan an array to determine if it contains a specific instance.
            function contains(a, obj) {
                for (var i = 0; i < a.length; i++) {
                    if (a[i] === obj) {
                        return true;
                    }
                }
                return false;
            }
            
            //find the index of value for a given key
            function findIndexByKeyValue(obj, key, value){
                for (var i = 0; i < obj.length; i++) {
                    if (obj[i][key] == value) {
                        return i;
                    }
                }
                return null;
            }
            
            //
            function graph_load(u,t,w){

            	// Clear out the contents of the DIV displaying the Node Graph at an instance.
            	$("#container2").html("");
                var week=w
                
                var id_them=u;
                var id_us=t;
                var width=500, height=610;
                var color = d3.scale.category20();
                
                var width=500, height=610;
                
                /***************************************************************************
                	This block of logic looks like a copy of an earlier block of code,
                	which implies it should be made into a function to be called in both
                	places, if this assumption is correct.  (Graham, can you confirm this?)
                ***************************************************************************/
                
                var force = d3.layout.force()
                .charge(-120)
                .linkDistance(30)
                .size([width, height]);
                
                var svg2 = d3.select("#container2").append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr("pointer-events","all")
                .append('svg:g')
                .call(d3.behavior.zoom().on("zoom", redraw))
                .append('svg:g');
                
                svg2.append('svg:rect')
                .attr('width', width)
                .attr('height', height)
                .attr('fill', 'white');
                
                function redraw() {
                    svg2.attr("transform",
                              "translate(" + d3.event.translate + ")"
                              + " scale(" + d3.event.scale + ")");
                }
                
                
                
                d3.json("network_retrieval?date="+week, function(error, graph) {
                	
                	// Associate the fetched data to the Node Graph
                    force
                        .nodes(graph.nodes)
                        .links(graph.links)
                        .start();
                   
                	// Define an array to manage the extract data
                   	var employees_id=[];
                	
                	// Fetch Employee Information
                    d3.csv("employees_id.csv",function(data){
                               employees_id=data
                  
             
                        //adds the name to the graph.nodes
                        function node_adder(nodes){
                               for (var i=0; i < nodes.length; i++) {
                                    var index=findIndexByKeyValue(graph.nodes,"id",i)
                                    if(index!=null){
                                        graph.nodes[index].name=employees_id[i].V2
                                    }
                               }
                        }

                        // Do the mapping
                        node_adder(employees_id);
                    
                        var max=d3.max(graph.nodes, function(d){return d.eigcen;})
                        
                       	// They (the two blocks) may not be same - the gradient's values seem to be different
                       	// If that's the only difference then this could be converted into a parameter
                       	// passed to the refactored function.
                        var color = d3.scale.linear()
                        .domain([0, max])
                        .range(["red","blue"]);
                        
                        // Create the object to manage the links between the nodes 
                        var link = svg2.selectAll("line.link")
                        .data(graph.links)
                        .enter().append("svg:line")
                        .attr("class", "link");
                        /*.style("stroke-width", function(d) { return Math.sqrt(d.value); 
                         .attr("x1", function(d) { return d.source.x; })
                         .attr("y1", function(d) { return d.source.y; })
                         .attr("x2", function(d) { return d.target.x; })
                         .attr("y2", function(d) { return d.target.y; });
                         */
                        
                        // Create the object to manage the nodes of the grapht
                        var node = svg2.selectAll("g.node")
                        .data(graph.nodes)
                        .enter().append("svg:g")
                        .attr("class", "node")
                        .call(force.drag);
                        
                        // Create an alias to the coloring selection algorithm 
                        var color_attribute=$(':checkbox').map(function () {
									if(this.checked) {
										return this.value;
									}
						}).get();
                               
                               
                        // Create the object to render the nodes of the graph
                        node.append("svg:circle")
                        .attr("class", "node")
                               .attr("r", function(d){return 1.5*Math.sqrt(d.degree+1)})
                               //.attr("r",3)
                        .style("fill", function(d) { 
                        					if(d.id==window.id_them) { 
                        						return "red"; 
                        					} else if (d.id==window.id_us) {
                        						return "blue"; 
                        					} else if (contains(window.pink,d.id)) {
                        						return "pink";  
                        					} else if (contains(window.baby_blue,d.id)) {
                        						return "lightblue"; 
                        					} else {
                               					return "black"; 
                               				}});
                        //.style("fill", function(d,i){return color(d.eigcen);});
                         
                        // Manage the coloring of the node based on the user's selection (COLOR_ATTRIBUTE)
                        if (color_attribute=="eig"){
                        	node.append("svg:circle")
		                        .attr("class", "node")
        		                .attr("r", function(d){return 1.5*Math.sqrt(d.degree+1)})
                		        .style("fill", function(d,i){return color(d.eigcen);});
                        }
                               
                        if (color_attribute=="bc"){
                      		node.append("svg:circle")
                            	.attr("class", "node")
                               	.attr("r", function(d){return 1.5*Math.sqrt(d.degree+1)})
                               	.style("fill", function(d,i){return color(d.betweenness);});
                        }

                        // Add the label to the node
                        node.append("svg:text")
                        	.attr("class", "nodetext")
                        	.attr("dx", 12)
                        	.attr("dy", ".35em")
                        	.text(function(d) { return d.name + ' ' +d.betweenness});
                        
						// Add the callback to allow the Force Graph to stablize
                        force.on("tick", function() {
                                 link.attr("x1", function(d) { return d.source.x; })
                                 .attr("y1", function(d) { return d.source.y; })
                                 .attr("x2", function(d) { return d.target.x; })
                                 .attr("y2", function(d) { return d.target.y; });
                                 
                                 /*node.attr("cx", function(d) { return d.x; })
                                  .attr("cy", function(d) { return d.y; });*/
                                 
                                 node.attr("transform", function(d) {
                                           return 'translate(' + [d.x, d.y] + ')';
                                           });
                                 });

                        });
                        
            });
                
            }
                
            // Add the event handler to the 'LEFT' Navigation button.
            $("#left").bind("click", function(event) {
                            window.week-=1
                            graph_load(window.id_us,window.id_them,window.week);
                            //$("#nav").append("<center><p> t="+window.week+"</p></center>");
                                     });
            
            // Add the event handler to the 'RIGHT' Navigation button.
            $("#right").bind("click", function(event) {
                             window.week+=1
                             graph_load(window.id_us,window.id_them,window.week);
                             var canvas = document.getElementById('time_series')
                             var img    = canvas.toDataURL("image/png");
                             //window.open(canvas.toDataURL(), 'new_window', 'width=310,height=30')
                            });

            // Add the event handler to the Rendering Style Check List (this should be implemented as Radio Buttons)
            $(":checkbox").change(function(event) {
         					if(this.checked) {
                                  var color_attribute=$(':checkbox').map(function () {      
                                	  		if(this.checked) {
												return this.value;
											}
                                  	}).text();
                                  
                                  }
                           var selectedNodeCircles = d3.selectAll("g.node");
                           if (color_attribute=="eig"){
                                  selectedNodeCircles.transition().attr("r",10)
                                  
                           }
				});
            
        
           
            </script>

</body>
</html>
